// Generated by CoffeeScript 1.7.1
(function() {
  var Blanket, copynumber, coverageInfo, options, parseAndModify;

  parseAndModify = require('falafel');

  copynumber = Math.floor(Math.random() * 1000);

  coverageInfo = {};

  options = {
    reporter: null,
    adapter: null,
    filter: null,
    customVariable: null,
    loader: null,
    ignoreScriptError: false,
    existingRequireJS: false,
    autoStart: false,
    timeout: 180,
    ignoreCors: false,
    branchTracking: false,
    sourceURL: false,
    debug: false,
    engineOnly: false,
    testReadyCallback: null,
    commonJS: false,
    instrumentCache: false,
    modulePattern: null
  };

  Blanket = (function() {
    function Blanket() {
      this._trackingArraySetup = [];
      this._branchingArraySetup = [];
      this.linesToAddTracking = ['ExpressionStatement', 'BreakStatement', 'ContinueStatement', 'VariableDeclaration', 'ReturnStatement', 'ThrowStatement', 'TryStatement', 'FunctionDeclaration', 'IfStatement', 'WhileStatement', 'DoWhileStatement', 'ForStatement', 'ForInStatement', 'SwitchStatement', 'WithStatement'];
      this.linesToAddBrackets = ['IfStatement', 'WhileStatement', 'DoWhileStatement', 'ForStatement', 'ForInStatement', 'WithStatement'];
    }

    Blanket.prototype._getCopyNumber = function() {
      return copynumber;
    };

    Blanket.prototype.extend = function(obj) {
      return this._extend(this, obj);
    };

    Blanket.prototype._extend = function(dest, source) {
      var key, value, _results;
      if (source) {
        _results = [];
        for (key in source) {
          value = source[key];
          if (dest[key] instanceof Object && typeof dest[key] !== 'function') {
            _results.push(this._extend(dest[key], source[key]));
          } else {
            _results.push(dest[key] = value);
          }
        }
        return _results;
      }
    };

    Blanket.prototype.getCovVar = function() {
      var opt;
      opt = this.options('customVariable');
      if (opt) {
        if (this.options('debug')) {
          console.log("BLANKET-Using custom tracking variable:", opt);
        }
        return opt;
      }
      return "_$jscoverage";
    };

    Blanket.prototype.options = function(key, value) {
      if (typeof key !== 'string') {
        return this._extend(options, key);
      } else if (typeof value === 'undefined') {
        return options[key];
      } else {
        return options[key] = value;
      }
    };

    Blanket.prototype.instrument = function(config, next) {
      var inFile, inFileName, instrumented, sourceArray;
      inFile = config.inputFile;
      inFileName = config.inputFileName;
      if (this.options('instrumentCache') && sessionStorage && sessionStorage.getItem('blanket_instrument_store-' + inFileName)) {
        if (this.options('debug')) {
          console.log("BLANKET-Reading instrumentation from cache: ", inFileName);
        }
        return next(sessionStorage.getItem("blanket_instrument_store-" + inFileName));
      } else {
        sourceArray = this._prepareSource(inFile);
        this._trackingArraySetup = [];
        inFile = inFile.replace(/^\#\!.*/, "");
        instrumented = parseAndModify(inFile, {
          loc: true,
          comment: true
        }, this._addTracking(inFileName));
        instrumented = this._trackingSetup(inFileName, sourceArray) + instrumented;
        if (this.options("sourceURL")) {
          instrumented += "\n//@ sourceURL=" + inFileName.replace("http://", "");
        }
        if (this.options("debug")) {
          console.log("BLANKET-Instrumented file: ", inFileName);
        }
        if (this.options("instrumentCache") && sessionStorage) {
          if (this.options("debug")) {
            console.log("BLANKET-Saving instrumentation to cache: ", inFileName);
          }
          sessionStorage.setItem("blanket_instrument_store-" + inFileName, instrumented);
        }
        return next(instrumented);
      }
    };

    Blanket.prototype._prepareSource = function(source) {
      return source.replace(/\\/g, "\\\\").replace(/'/g, "\\'").replace(/(\r\n|\n|\r)/gm, "\n").split('\n');
    };

    Blanket.prototype._trackingSetup = function(filename, sourceArray) {
      var branches, covVar, intro, sourceString;
      branches = this.options("branchTracking");
      sourceString = sourceArray.join("',\n'");
      intro = '';
      covVar = this.getCovVar();
      intro += "if (typeof " + covVar + " === 'undefined') " + covVar + " = {};\n";
      if (branches) {
        intro += "var _$branchFcn=function(f,l,c,r){ ";
        intro += "if (!!r) { ";
        intro += covVar + "[f].branchData[l][c][0] = " + covVar + "[f].branchData[l][c][0] || [];";
        intro += covVar + "[f].branchData[l][c][0].push(r); }";
        intro += "else { ";
        intro += covVar + "[f].branchData[l][c][1] = " + covVar + "[f].branchData[l][c][1] || [];";
        intro += covVar + "[f].branchData[l][c][1].push(r); }";
        intro += "return r;};\n";
      }
      intro += "if (typeof " + covVar + "['" + filename + "'] === 'undefined'){";
      intro += covVar + "['" + filename + "']=[];\n";
      if (branches) {
        intro += covVar + "['" + filename + "'].branchData=[];\n";
      }
      intro += covVar + "['" + filename + "'].source=['" + sourceString + "'];\n";
      this._trackingArraySetup.sort(function(a, b) {
        return parseInt(a, 10) > parseInt(b, 10);
      }).forEach(function(item) {
        return intro += covVar + "['" + filename + "'][" + item + "]=0;\n";
      });
      if (branches) {
        this._branchingArraySetup.sort(function(a, b) {
          return a.line > b.line;
        }).sort(function(a, b) {
          return a.column > b.column;
        }).forEach(function(item) {
          if (item.file === filename) {
            intro += "if (typeof " + covVar + "['" + filename + "'].branchData[" + item.line + "] === 'undefined'){\n";
            intro += covVar + "['" + filename + "'].branchData[" + item.line + "]=[];\n";
            intro += "}";
            intro += covVar + "['" + filename + "'].branchData[" + item.line + "][" + item.column + "] = [];\n";
            intro += covVar + "['" + filename + "'].branchData[" + item.line + "][" + item.column + "].consequent = " + JSON.stringify(item.consequent) + ";\n";
            return intro += covVar + "['" + filename + "'].branchData[" + item.line + "][" + item.column + "].alternate = " + JSON.stringify(item.alternate) + ";\n";
          }
        });
      }
      intro += "}";
      return intro;
    };

    Blanket.prototype._blockifyIf = function(node) {
      var bracketsExistAlt, bracketsExistObject;
      if (this.linesToAddBrackets.indexOf(node.type) > -1) {
        bracketsExistObject = node.consequent || node.body;
        bracketsExistAlt = node.alternate;
        if (bracketsExistAlt && bracketsExistAlt.type !== 'BlockStatement') {
          bracketsExistAlt.update('{\n' + bracketsExistAlt.source() + '}\n');
        }
        if (bracketsExistObject && bracketsExistObject.type !== 'BlockStatement') {
          return bracketsExistObject.update('{\n' + bracketsExistObject.source() + '}\n');
        }
      }
    };

    Blanket.prototype._trackBranch = function(node, filename) {
      var col, line, updated;
      line = node.loc.start.line;
      col = node.loc.start.column;
      this._branchingArraySetup.push({
        line: line,
        column: col,
        file: filename,
        consequent: node.consequent.loc,
        alternate: node.alternate.loc
      });
      updated = "_$branchFcn" + "('" + filename + "'," + line + "," + col + "," + node.test.source() + ")?" + node.consequent.source() + ":" + node.alternate.source();
      return node.update(updated);
    };

    Blanket.prototype._addTracking = function(filename) {
      var covVar;
      covVar = this.getCovVar();
      return (function(_this) {
        return function(node) {
          _this._blockifyIf(node);
          if (_this.linesToAddTracking.indexOf(node.type) > -1 && node.parent.type !== 'LabeledStatement') {
            _this._checkDefs(node, filename);
            if (node.type === 'VariableDeclaration' && (node.parent.type === 'ForStatement' || node.parent.type === 'ForInStatement')) {
              return;
            }
            if (node.loc && node.loc.start) {
              node.update(covVar + "['" + filename + "'][" + node.loc.start.line + "]++;\n" + node.source());
              return _this._trackingArraySetup.push(node.loc.start.line);
            } else {
              throw new Error("The instrumenter encountered a node with no location: " + Object.keys(node));
            }
          } else if (_this.options("branchTracking") && node.type === 'ConditionalExpression') {
            return _this._trackBranch(node, filename);
          }
        };
      })(this);
    };

    Blanket.prototype._checkDefs = function(node, filename) {
      if (node.type === 'ExpressionStatement' && node.expression && node.expression.left && !node.expression.left.object && !node.expression.left.property && node.expression.left.name === this.getCovVar()) {
        throw new Error("Instrumentation error, you cannot redefine the coverage variable in  " + filename + ":" + node.loc.start.line);
      }
    };

    Blanket.prototype.setupCoverage = function() {
      coverageInfo.instrumentation = 'blanket';
      return coverageInfo.stats = {
        suites: 0,
        tests: 0,
        passes: 0,
        pending: 0,
        failures: 0,
        start: new Date()
      };
    };

    Blanket.prototype._checkIfSetup = function() {
      if (!coverageInfo.stats) {
        throw new Error("You must call blanket.setupCoverage() first.");
      }
    };

    Blanket.prototype.onTestStart = function() {
      if (this.options("debug")) {
        console.log("BLANKET-Test event started");
      }
      this._checkIfSetup();
      coverageInfo.stats.tests++;
      return coverageInfo.stats.pending++;
    };

    Blanket.prototype.onTestDone = function(total, passed) {
      this._checkIfSetup();
      if (passed === total) {
        coverageInfo.stats.passes++;
      } else {
        coverageInfo.stats.failures++;
      }
      return coverageInfo.stats.pending--;
    };

    Blanket.prototype.onModuleStart = function() {
      this._checkIfSetup();
      return coverageInfo.stats.suites++;
    };

    Blanket.prototype.onTestsDone = function() {
      if (this.options("debug")) {
        console.log("BLANKET-Test event done");
      }
      this._checkIfSetup();
      coverageInfo.stats.end = new Date();
      if (!this.options("branchTracking")) {
        delete global[this.getCovVar()].branchFcn;
      }
      return this.options("reporter").call(this, coverageInfo);
    };

    return Blanket;

  })();

  exports.blanket = new Blanket();

}).call(this);
